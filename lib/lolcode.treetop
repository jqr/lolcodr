grammar LOLCode
  rule program
    start more_expressions:(expression)* {
      def run(env = {})
        value = nil
        more_expressions.elements.each do |expression|
          value = expression.value(env)
        end
        [value, env]
      end
    }
  end
  
  rule start
    'HAI' os nl
  end
  
  rule expression
    os real_expression os nl {
      def value(env = {})
        real_expression.value(env)
      end
    }
  end
  
  rule real_expression
    builtin_command / variable_declaration / string / number / boolean
  end

  rule builtin_command
    exit / print
  end
  
  rule exit
    'KTHXBYE' { def value(env = {}); exit; end }
  end
  
  rule print
    'VISIBLE' s real_expression {
      def value(env = {})
        puts real_expression.value
      end
    }
  end
  
  rule variable_declaration
    variable_declaration_with_set / variable_declaration_without_set
  end

  rule variable_declaration_with_set
    'I' s 'HAS' s 'A' s variable s 'ITZ' real_expression {
      def value(env = {})
        env[variable.text_value] = real_expression.value
      end
    }
  end
  
  rule variable_declaration_without_set
    'I' s 'HAS' s 'A' s variable {
      def value(env = {})
        env[variable.text_value] = nil
      end
    }
  end
  
  rule variable
    alpha alnum* !alnum
  end
  
  rule string
    '"' literal:(!["] .)* '"' { def value(env = {}); literal.text_value; end }
  end
  
  rule number
    float / integer
  end

  rule float
    os ([1-9] [0-9]* '.' [0-9]+) os	{ def value(env = {}); text_value.to_f; end }
  end
  
  rule integer
    os ([1-9] [0-9]* / '0') os	{ def value(env = {}); text_value.to_i; end }
  end
  
  rule boolean
    ('WIN' / 'FAIL') {
      def value(env = {})
        text_value == 'WIN'
      end
    }
  end

  rule s
    [ \t]+
  end
  
  rule os
    s*
  end

  rule ns
    ![ \t] .
  end
  
  rule nl
    [\n]
  end

  rule alpha
    [a-zA-Z]
  end
  
  rule numeric
    [0-9]
  end
  
  rule alnum
    alpha / numeric
  end  
end
